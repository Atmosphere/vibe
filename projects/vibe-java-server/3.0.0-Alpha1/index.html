---
layout: project
title: Vibe Java Server
---

<p>A simple <sup><strong>A</strong></sup>, scalable <sup><strong>B</strong></sup> Java server designed to run any framework or platform on Java Virtual Machine <sup><strong>C</strong></sup>.</p>
<dl>
    <dt>A</dt>
    <dd>All interface you need to know is Server and Socket. Indeed.</dd>
    <dt>B</dt>
    <dd>Shared nothing architecture is adopted to help scale application horizontally with ease.</dd>
    <dt>C</dt>
    <dd>Because it is built on Vibe Java Server Platform which is I/O abstraction layer, you can run your application on any platform that it supports seamlessly e.g. Play, Vert.x, Atmosphere and Servlet.</dd>
</dl>
<hr />
<h2>Getting Started</h2>
<p>Vibe Java Server is distributed through Maven Central. A single artifact, <code>org.atmosphere:vibe:3.0.0-Alpha1</code>, is enough for general purpose and thanks to Vibe Java Server Platform, your application can run on any framework or platform it supports.</p>

<h3>Basic</h3>
{% capture panel %}
Let's write a simple server for echo and chat running on the top of Servlet container. Add the following dependencies to your build or include them on classpath manually.

```xml
<dependencies>
    <dependency>
        <groupId>org.atmosphere</groupId>
        <artifactId>vibe</artifactId>
        <version>3.0.0-Alpha1</version>
    </dependency>
    <dependency>
        <groupId>org.atmosphere</groupId>
        <artifactId>vibe-platform-atmosphere2</artifactId>
        <version>3.0.0-Alpha1</version>
    </dependency>
</dependencies>
```

Once you've set up your build, you'll be able to write `Bootstrap.java`.

```java
// TODO vibe imports

import javax.servlet.*;
import javax.servlet.annotation.WebListener;

@WebListener // A
public class Bootstrap implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent event) {
        Server server = new DefaultServer(); // B
        server.socketAction(new Action<Socket>() { // C
            @Override
            public void on(final Socket socket) {
                socket.on("echo", new Action<Object>() { // D
                    @Override
                    public void on(Object data) {
                        socket.send("echo", data);
                    }
                });
                socket.on("chat", new Action<Object>() { // E
                    @Override
                    public void on(Object data) {
                        server.all().send("chat", data);
                    }
                });
            }
        });

        ServletContext servletContext = event.getServletContext();
        new AtmosphereBridge(servletContext, "/vibe").httpAction(server.httpAction()).websocketAction(server.websocketAction()); // F
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {}
}
```
{% endcapture %}{{ panel | markdownify }}

<dl>
    <dt>A <code>@WebListener</code></dt>
    <dd>It declares <code>Bootstrap</code> as a listener. Accordingly, once the servlet container starts, <code>contextInitialized</code> is executed.</dd>
    <dt>B <code>Server server = new DefaultServer()</code></dt>
    <dd>It creates a server instance by new keyword so you can delegate its creation to other framework like Spring.</dd>
    <dt>C <code>server.socketAction(socket -> {})</code></dt>
    <dd>It adds an action to be executed when a socket representing client has been opened. There is no restriction to add an action. Therefore you can add multiple actions before and after installation.</dd>
    <dt>D <code>socket.on("echo", data -> socket.send("echo", data))</code></dt>
    <dd>When the socket receives <code>echo</code> event, sends it back.</dd>
    <dt>E <code>socket.on("chat", data -> server.all().send("chat", data))</code></dt>
    <dd>When the socket receives <code>chat</code> event, sends it to all sockets that have connected to this server. To select a single or a group of specific sockets, use <code>server.byId</code> or <code>server.byTag</code>.</dd>
    <dt>F <code>new AtmosphereBridge(servletContext, "/vibe").httpAction(server.httpAction()).websocketAction(server.websocketAction())</code></dt>
    <dd>As a platform of Vibe Java Server Platform, Atmosphere will deliver HTTP and WebSocket connections whose a request path belongs to <code>/vibe</code> from the Servlet container to the server.</dd>
</dl>

<h3>Advanced</h3>
{% capture panel %}
Following the basic example, in this time, let's scale application with the help of [Hazelcast](http://hazelcast.com/). Add the following dependencies to your build or include them on classpath manually.

```xml
<dependencies>
    <dependency>
        <groupId>com.hazelcast</groupId>
        <artifactId>hazelcast</artifactId>
        <version>3.2</version>
    </dependency>
    <dependency>
        <groupId>com.hazelcast</groupId>
        <artifactId>hazelcast-client</artifactId>
        <version>3.2</version>
    </dependency>
</dependencies>
```

Once you've set up your build, you'll be able to write `Bootstrap.java`.

```java
// TODO vibe imports

import java.util.Map;

import javax.servlet.*;
import javax.servlet.annotation.WebListener;

import com.hazelcast.config.Config;
import com.hazelcast.core.*;
import com.hazelcast.instance.HazelcastInstanceFactory;

@WebListener
public class Bootstrap implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent event) {
        HazelcastInstance hazelcast = HazelcastInstanceFactory.newHazelcastInstance(new Config());
        final ClusteredServer server = new ClusteredServer(); // A
        final ITopic<Map<String, Object>> topic = hazelcast.getTopic("vibe");
        
        topic.addMessageListener(new MessageListener<Map<String, Object>>() { // B
            @Override
            public void onMessage(Message<Map<String, Object>> message) {
                server.messageAction().on(message.getMessageObject());
            }
        });
        server.publishAction(new Action<Map<String, Object>>() { // C
            @Override
            public void on(Map<String, Object> message) {
                topic.publish(message);
            }
        });
        
        server.socketAction(new Action<Socket>() {
            @Override
            public void on(final Socket socket) {
                socket.on("echo", new Action<Object>() {
                    @Override
                    public void on(Object data) {
                        socket.send("echo", data);
                    }
                });
                socket.on("chat", new Action<Object>() { // D
                    @Override
                    public void on(Object data) {
                        server.all().send("chat", data);
                    }
                });
            }
        });
        
        ServletContext servletContext = event.getServletContext();
        new AtmosphereBridge(servletContext, "/vibe").httpAction(server.httpAction()).websocketAction(server.websocketAction());
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {}
}
```
{% endcapture %}{{ panel | markdownify }}

<dl>
    <dt>A <code>ClusteredServer server = new ClusteredServer()</code></dt>
    <dd><code>ClusteredServer</code> uses a publish and subscribe model to scale application, which is a very basic functionality of Message Oriented Middleware or Data Grid.</dd>
    <dt>B <code>topic.addMessageListener(message -> server.messageAction().on(message.getMessageObject()))</code></dt>
    <dd>It subscribes the topic to receive messages from every server in the cluster. If a message has arrived, the server will do something following the message as if it did happen originally in this server.</dd>
    <dt>C <code>server.publishAction(message -> topic.publish(message))</code></dt>
    <dd>It publishes a message to the topic to send messages to every server in the cluster. Among many operations on server, ones required for all servers in the cluster to do something together are published as message.</dd>
    <dt>D <code>socket.on("chat", data -> server.all().send("chat", data))</code></dt>
    <dd>When the socket receives <code>chat</code> event, sends it to all sockets that have connected to each server forming the cluster. The same way applies to <code>server.byId</code> and <code>server.byTag</code>.</dd>
</dl>